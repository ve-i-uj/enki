"""Скрипт добавляет атрибуты hasBase, hasCell, hasClient сущности в entities.xml.

Скрипт однозначно прописывает в entities.xml наличие hasCell, hasBase,
hasClient, основываясь на том, что написано в файле entities.xml и на наличии
методов и свойств сущности. Это решает проблему непрозрачного выставления KBEngine
по умолчанию значений этим атрибутам.

Наприер, есть следующая проблема:
Из-за того, что в kbengine-demo-assets всем сущностям записан GameObject
в интерфейсы, все сущности имеют cell и client
свойства. При запуске компонентов в отдельном контейнере KBEngine
выдаёт ошибку, что не указано у сущности, что она имеет cell
составляющую (hasCell не указана в entities.xml). Поэтому нужно
поправить этот файл перед помещением в контейнер. Если же все серверные
компоненты в одном контейнере, то hasCell высчитывается по какой-то неизвестной
логике и проблемы не возникает. Почему это так - неизвестно.
"""

import enum
import logging
from pathlib import Path

from enki.misc import log

from tools import parsers
from tools.parsers import EntitiesXMLParser, EntityDefParser, EntitiesXMLData

from tools.normalize_entitiesxml import settings

logger = logging.getLogger(__name__)


_SCRIPTS_DIR = settings.GAME_ASSETS_DIR / 'scripts'


class _EModuleComp(enum.Enum):
    """Entity module component."""
    CELL = enum.auto()
    BASE = enum.auto()


def _get_entity_path(entity_name: str, comp: _EModuleComp) -> Path:
    return _SCRIPTS_DIR / comp.name.lower() / f'{entity_name}.py'


_ENTITY_MODULE_TEMPLATE = '''
"""Generated by enki/tools/normalize_entitiesxml .

https://github.com/ve-i-uj/enki
"""

import KBEngine


class {entity_name}(KBEngine.Entity):
    pass

'''

def _add_empty_entity_module(entity_name: str, entity_module_path: Path):
    with entity_module_path.open('w') as fh:
        fh.write(_ENTITY_MODULE_TEMPLATE.format(entity_name=entity_name))


def _normalizy_entity_module(exml_data: EntitiesXMLData):
    """Добавить пустой модуль сущности в assets, если его нет."""
    scripts_dir = settings.GAME_ASSETS_DIR / 'scripts'
    for e_data in exml_data.get_all():
        base_module_path = _get_entity_path(e_data.name, _EModuleComp.BASE)
        cell_module_path = _get_entity_path(e_data.name, _EModuleComp.CELL)
        if e_data.hasBase and not base_module_path.exists():
            _add_empty_entity_module(e_data.name, base_module_path)
            logger.info(f'There is no module {_EModuleComp.BASE.name.lower()}/{e_data.name}. '
                        f'An empty module added.')
        if e_data.hasCell and not cell_module_path.exists():
            _add_empty_entity_module(e_data.name, cell_module_path)
            logger.info(f'There is no module {_EModuleComp.BASE.name.lower()}/{e_data.name}. '
                        f'An empty module added.')


def main():
    log.setup_root_logger(logging.getLevelName(settings.LOG_LEVEL))
    logger.info('Force add hasBase, hasCell, hasClient to the entities in the '
                'entities.xml file ...')
    exml_parser = EntitiesXMLParser(settings.ENTITIES_XML_PATH)
    exml_data = exml_parser.parse()
    edef_parser = EntityDefParser(settings.ENTITY_DEFS_DIR)
    edef_data = {
        ed.name: edef_parser.parse(ed.name) for ed in exml_data.get_all()
    }
    updated_exml_data = parsers.utils.normalize_entitiesxml(
        exml_data, edef_data
    )
    updated_exml_data.to_file(settings.UPDATED_ENTITIES_XML_PATH)
    logger.info(f'The updated entities.xml file has been written to the '
                f'"{settings.UPDATED_ENTITIES_XML_PATH}" file')

    if settings.ADD_EMPTY_ENTITY_MODULE:
        _normalizy_entity_module(updated_exml_data)


if __name__ == '__main__':
    main()
